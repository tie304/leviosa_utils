use serde::{Deserialize, Serialize};
use sqlx::{
    database::HasValueRef,
    encode::IsNull,
    postgres::{PgArgumentBuffer, PgTypeInfo},
    Decode, Encode, Postgres, Type,
};
use std::{error::Error, marker::PhantomData};

// Denotes an autogenerated value such as a DEFAULT, SERIAL,
#[derive(Debug, Clone, sqlx::Type, Copy, Serialize, Deserialize)]
#[sqlx(transparent)]
pub struct AutoGenerated<T>(pub T);

#[derive(Debug, Clone, Copy, Type, PartialEq)]
#[sqlx(transparent)]
pub struct RelationId(pub i32);

// This struct is used within your Rust code to carry around the type information
// without affecting the database schema or operations.
#[derive(Debug, Clone, Copy)]
pub struct Relation<T> {
    pub id: i32,
    _phantom: PhantomData<T>,
}

impl<T> Relation<T> {
    pub fn new(id: i32) -> Self {
        Relation {
            id,
            _phantom: PhantomData,
        }
    }
}

// Implement `Encode` for `Relation<T>` by delegating to `i32`
impl<'q, T> Encode<'q, Postgres> for Relation<T> {
    fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> IsNull {
        // Delegate encoding to the inner `i32`
        <i32 as Encode<'_, Postgres>>::encode_by_ref(&self.id, buf)
    }

    fn size_hint(&self) -> usize {
        // Delegate size hint to the inner `i32`
        <i32 as Encode<'_, Postgres>>::size_hint(&self.id)
    }
}

impl<'q, T> Decode<'q, Postgres> for Relation<T> {
    fn decode(
        value: <Postgres as HasValueRef<'q>>::ValueRef,
    ) -> Result<Relation<T>, Box<dyn Error + 'static + Send + Sync>> {
        let id = <i32 as Decode<Postgres>>::decode(value)?;
        Ok(Relation {
            id,
            _phantom: PhantomData,
        })
    }
}

impl<T> Type<Postgres> for Relation<T> {
    fn type_info() -> PgTypeInfo {
        <i32 as Type<Postgres>>::type_info()
    }
}
